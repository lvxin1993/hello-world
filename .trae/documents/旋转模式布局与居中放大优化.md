## 目标
- 优化布局：调节速度的控件整体下移至轮播下方，增加底部留白，避免内容集中在中间。
- 居中放大：卡片滑动到屏幕中央位置时自动放大，提升聚焦与层次感。

## 布局调整
1) 将现有的 controlsContainer 从绝对定位改为普通流式布局，放在轮播 ScrollView 下面：
- 删除 controlsContainer 的 position: 'absolute' 与 bottom 样式。
- 给 rotatingModeContainer 设置更合理的垂直排布：justifyContent: 'flex-start'、paddingTop 与 paddingBottom 增加下部空间。
- 在 ScrollView 之后渲染 controlsContainer，并设置 marginTop（如 16）与更宽的容器宽度（如 90%），使其靠近页面底部而非覆盖中间。

2) 视觉留白与对齐
- rotatingScrollView 保持 width:'100%'，确保横向滚动可见。
- 在容器底部增加 spacer（例如高度 24）或通过 paddingBottom 控制页面留白。

## 居中放大实现
1) 使用 scrollX + cellWidth 计算每个卡片的缩放：
- 在渲染 duplicatedItems 时，给每项外层包一层 Animated.View。
- scale = scrollX.interpolate({ inputRange: [(index-1)*cellWidth, index*cellWidth, (index+1)*cellWidth], outputRange: [0.95, 1.08, 0.95], extrapolate: 'clamp' })。
- transform: [{ scale }] 并使用 useNativeDriver: true（仅用于 Animated.View 的缩放）。
- 可选：中心卡片增加轻微阴影/elevation，以增强层次。

2) 与现有逻辑兼容
- scrollX 在自动循环与拖拽中已通过 setValue 同步，缩放可实时响应。
- 继续保留基于速度方向的边界判断与两阶段惯性，点击索引扣除 padding。

## 验证
- Web 与原生端：卡片横向自动移动，居中卡片明显放大；控件栏位于轮播下方，页面底部留白足够。
- 方向与速度调整正常工作；拖拽与惯性平顺。

## 风险与回退
- 若某些平台缩放导致布局抖动，可将最大缩放从 1.08 调整到 1.05 并减少阴影。
- 如需更高性能，后续可迁移缩放与位移到 reanimated，在 UI 线程驱动。