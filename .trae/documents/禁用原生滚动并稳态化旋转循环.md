## 目标
- 彻底消除 ScrollView 原生滚动与 JS 手动控制之间的冲突，使自动旋转与拖拽、惯性、无限循环稳定运行。
- 优化初始化与依赖，避免动画频繁重启或位置跳跃。

## 修改项
### 1) 禁用原生滚动
- 在 Animated.ScrollView 上添加：
```jsx
<Animated.ScrollView
  scrollEnabled={false}
  /* 其余现有属性保持不变 */
/>
```
- 交互完全由 PanResponder 与 scrollTo 控制，消除与原生滚动的竞争。
- 在循环与拖拽中继续使用 scrollViewRef.current.scrollTo({ x, animated: false })。

### 2) 手动同步 scrollX（保障卡片动效）
- 在自动循环与拖拽应用位移时同步设置 scrollX 值，以防 scrollEnabled=false 时部分平台不触发 onScroll：
```js
scrollViewRef.current?.scrollTo({ x: currentScrollPos.current, animated: false });
scrollX.setValue(currentScrollPos.current);
```

### 3) 初始化与循环启动时机
- 引入 didInitRef：仅在首次有效数据加载时设置初始位置（menuLength * cellWidth）。
- 循环在 didInitRef 为真后再开始，或在 loop 内前置判断：
```js
if (!didInitRef.current) { animationFrameId.current = requestAnimationFrame(loop); return; }
```

### 4) 依赖瘦身与派生值引用
- 移除 cellWidth 作为动画循环 useEffect 的依赖，改为使用 ref 持有：
```js
const cellWidthRef = useRef(cellWidth);
useEffect(() => { cellWidthRef.current = cellWidth; }, [cellWidth]);
```
- 动画循环依赖改为：[rotationDirection, rotationSpeed, menuLength]。
- 边界与步进使用 cellWidthRef.current，避免因 render 造成 effect 重启。

### 5) 已落实的交互与边界优化（保留）
- 边界判断基于速度方向 isMovingRight，避免惯性左滑露白。
- INERTIA 两阶段：先纯摩擦衰减，速度低后切回 AUTO。
- 拖拽与点击阈值提升，减少误判；点击索引扣除 padding。

## 兼容性与注意
- Web 端通常仍会响应 scrollTo 的 onScroll，但为保险起见我们手动同步 scrollX。
- backdropFilter 已移除，避免 Android 不支持导致表现不一致。

## 验证
- Web 端与原生端同时验证：
  - 自动旋转持续且方向/速度可调；拖拽与惯性自然，无露白；无限循环平滑。
  - 一屏展示 3–4 张卡片，卡片宽≈间距 3 倍。
  - 多次切换模式与返回页面，动画不重启或卡顿；屏幕旋转后位置按比例平滑调整。

## 风险与回滚
- 风险：scrollEnabled=false 在某些 RN Web 实现可能被忽略；但我们仍通过 scrollTo + setValue 保证表现一致。
- 回滚：若禁用原生滚动影响特定平台的滚动惯性体验，可恢复 scrollEnabled=true，并改为用 reanimated 在 UI 线程驱动滚动或 transform；保持其余修复不变。
