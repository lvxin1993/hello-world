## 根因分析
- Web端滚动未生效：在 RotatingModeView.js 的动画循环中，Platform.OS === 'web' 分支使用 scrollViewRef.current.getScrollableNode() 直接操作 DOM，但 Animated.ScrollView 的 ref 不是原生节点，getScrollableNode 返回空导致未滚动。
- 交互暂停影响：PanResponder 在 onPanResponderGrant 中把模式置为 PAUSED，若点击/拖动频繁，恢复存在延迟；但主要问题仍是 Web 分支未滚动。
- 布局未满足“3-4个卡片可见、卡片宽≈间距3倍”：当前 VISIBLE_ITEMS=5，且未设置水平间距，导致卡片过窄且紧密。

## 修改方案
1) 修复自动转动
- 统一使用 scrollViewRef.current.scrollTo({ x, animated: false })，移除 Web 端直接 DOM 操作与 dispatchEvent，保证跨平台一致性。
- 保留 requestAnimationFrame 循环；确保 loop 在组件卸载时 cancelAnimationFrame；依赖保持 menuItems、rotationDirection、rotationSpeed、尺寸参数变化时重启。
- 防御：当 scrollViewRef.current 不存在时跳过一次写入，避免异常。

2) 优化卡片宽度与间距（目标：一屏容纳 3-4 张，卡片宽≈间距3倍）
- 采用“等比可见数”计算：设期望可见数为 3.5（介于 3 与 4），令间距 SPACING = cardWidth / 3；每张实际占宽 widthWithSpacing = cardWidth + SPACING。
- 根据屏宽计算 cardWidth = screenWidth / (visibleCount + visibleCount/3) = screenWidth * 3 / (4 * 3.5)。
- 使用 cellWidth = cardWidth + SPACING 参与所有滚动与索引计算（blockWidth、初始定位、点击索引、边界循环），保证逻辑与视觉一致。
- 视觉实现：每个卡片外层容器设置宽度为 cellWidth，卡片本体宽度为 cardWidth；在容器上应用 marginHorizontal: SPACING/2，使相邻卡片间距累计为 cardWidth/3。
- padding 居中：contentContainerStyle 的 paddingHorizontal 改为 (screenWidth - cellWidth) / 2。

3) 交互与点击索引修正
- 所有按卡片索引的计算（例如点击命中、居中索引）改为基于 cellWidth，而非 cardWidth，避免间距引入的误差。
- 保持 DRAGGING/INERTIA/AUTO 状态机不变，仅替换位移与索引的单位宽度。

## 兼容性与验证
- 开发验证：在 Web 与原生端分别启动应用，观察自动滚动是否恢复；验证切换旋转方向与速度的响应性。
- 视觉验证：在常见屏宽下（移动端窄屏、桌面宽屏），确认一屏可见约 3-4 张卡片；测量卡片间距约为卡片宽度的 1/3。
- 交互验证：拖拽后惯性恢复与点击命中卡片正确；边界循环无跳变。

## 风险与回滚
- 风险：若历史依赖某些以 cardWidth 为单位的动画插值，需要同步改为 cellWidth；本次仅 RotatingModeView 内部替换。
- 回滚：如视觉或性能不达预期，可将 visibleCount 改为固定 3 或 4，或暂时恢复旧的 cardWidth 逻辑并仅保留 scrollTo 修复。